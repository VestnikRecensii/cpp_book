\documentclass[book.tex]{subfiles}

%\input{common}
\begin{document}
\input{fontsize}

\chaptertitle{Функции}

\maketitle

\section*{Что такое функции}

В математике функцией называется соответствие между элементами двух множеств, установленное по такому правилу, что каждому элементу одного множества ставится в соответствие некоторый элемент из другого множества. В программировании понятие функция имеет несколько иное значение --- это фрагмент программного кода, к которому можно обратиться из другого места программы. Функции также называют подпрограммами.

Применяются функции для того, чтобы уменьшить количество кода и повысить структурированность. Сравните следующие два фрагмента:

\showfile{src/func1.cpp}{Код без функций}

\showfile{src/func2.cpp}{Код с функциями}

Второй вариант намного нагляднее --- он явно более структурированный, его проще читать, а при написании точно не ошибешься при копировании одинаковых строк.

Правила хорошего тона для функций гласят следующее:

\begin{itemize}
\item Функция должна иметь понятное имя. \cppword{fact}, \cppword{factorial} --- хорошие имена для фунции вычисления факториала, а \cppword{f1}, \cppword{func}, \cppword{function} --- нет.
\item Функция должна помещаться на один экран. 20--50 строк --- отличное значение для длины функции. Больше --- хуже.
\item Функция должна выполнять только одно логическое действие. Рассмотрим такой пример. Приложение запрашивает у пользователя логин и пароль, связывается с сервером и, если ответ положительный, пропускает пользователя дальше. Написание функции по имени 

\cppword{askLoginSendRequestGetToken}, 

объединяющее все эти действия внутри себя --- это плохо. Лучше сделать функцию \cppword{authorization}, которая внутри вызывает другие функции, например, \cppword{askLogin} и \cppword{getToken}, каждая из которых в свою очередь делает что-то более мелкое --- рисует окно с просьбой ввести логин и пароль, отправляет их на сервер и получает от него ответ.
\end{itemize}

\section*{Параметры и возвращаемые значения}

Функции может сообщить вызвавшему ее коду результат своей работы. Этот результат называется возвращаемым значением. Тип этого значения указывается перед названием функции. например, функция для суммирования двух целых чисел вероятнее всего имеет целый возвращаемый тип:

\showfile{src/sum.cpp}{Сумма двух чисел}

Данные, передаваемые в функцию, называются ее параметрами или аргументами. Различают формальные параметры --- те, которые указываются в описании функции, и фактические --- аргумент, передаваемый в функцию при вызове. В предыдущем примере \cppword{a} и \cppword{b} --- это формальные параметры, а \cppword{value1} и \cppword{10} --- фактические.

Конечно, функция может использовать не только свои параметры, но и глобальные переменные. Однако, в таком случае функция будет недетерминированной --- она может выдавать разный результат при одинаковых входных данных. А если функция к тому же изменяет глобальную переменную, осуществляет операции ввода-вывода, вызывает обработчики исключений или как-то иначе изменяет среду выполнения, то говорят, что функция имеет побочный эффект. По возможности избегайте подобного:

\showfile{src/bad_func.cpp}{Недетерминированные функции и побочный эффект}

\section*{Передача параметров по ссылке и значению}

Аргументы могут передаваться в функцию по значению и по ссылке. При передаче по значению объект, передаваемый в качестве аргумента в функцию, не может быть изменен внутри этой функции. В функцию передается само значение этого объекта. В случае передачи по ссылке можно изменять аргумент. Ссылки обозначаются знаком \cppword{\&} после имени типа:

\showfile{src/func_value_reference.cpp}{Передача по значению и ссылке}

Подробнее ссылки мы рассмотрим несколько позже, сейчас заметим, что их можно использовать для того, чтобы вернуть из функции не одно, а несколько значений. Также с их поммощью можно эффективнее передавать в функции данные сложных типов, т.к. при передаче по значению могут создаваться временные копии объектов.

%TODO: Перемещающие конструкторы и функции (C++11)

\section*{Рекурсия}

\fordummies{

Рекурсией называют определение, описание, изображение объекта или процесса внутри самого себя. Народная мудрость по этому поводу говорит: <<Чтобы понять рекурсию, нужно сначала понять рекурсию.>>

}

В программировании рекурсия --- вызов функции непосредственно из неё самой (простая рекурсия) или через другие функции (сложная или косвенная рекурсия). Наглядным примером рекурсии может служить факториал числа:

\showfile{src/recursion.cpp}{Вычисление факториала}

Рекурсивные функции обычно короче и нагляднее, чем их итеративные аналоги, однако они могут (но не обязаны) быть медленнее. Кроме того, в рекурсивной функции обязательно должно быть условие прекращения рекурсии, иначе программа свалится из-за слишком большой глубины и переполнения стека вызовов.

\section*{Объявление и определение}

В C++ есть важное различие между словами определение и объявление. 

Объявление переменной, функции или класса --- это сигнал компилятору, что существует сущность определенного типа с определенным именем. Компилятор может обрабатывать большую часть использований этого имени без необходимости полного определения этого имени.

Определение какой-то сущности означает предоставление полной информации для создания этой сущности. Определение функции включает в себя имя, тип, полную информацию об аргументах (их количество, типы и имена), а также тело функции. Определение класса означает предоставление всех методов и полей класса (но об этом поговорим в соответствующем разделе).

Определение также является объявлением, но не наоборот. У любого объекта может быть сколько угодно объявлений, но только одно определение. Перед своим вызовом функция должна быть объявлена, поэтому объявления пишут либо перед первым использованием функции, либо в подключаемых заголовочных файлах или <<хедерах>> (модульное программирование рассмотрим позже).

\showfile{src/declarations_and_definitions.cpp}{Объявления и определения}

\section*{Перегрузка функций}

В языке C в программе может существовать только одна функция с определенным именем\footnote{В стандарте C11 появились дженерик-макросы, позволяющие создавать функции общего назначения. Они выбирают функцию в зависимости от типа переданных аргументов.}. В C++ появился механизм перегрузки --- возможность использования одноимённых функций с разными типами и количеством аргументов. Но нужно помнить, что перегруженные функции должны быть однозначно различимы компилятором:

\showfile{src/overload.cpp}{Перегрузка функций}

\section*{Некоторые стандартные функции}

C++ унаследовал от C богатую стандартную библиотеку. Для подключения модуля нужно использовать директиву \cppword{\#include} с именем соответствующего файла. Все модули из стандартной библиотеки языка C начинаются с буквы <<c>> (латинская си).

Например, строкой \cppword{\#include<cmath>} подключаются математические функции: \cppword{sqrt(x), pow(x, y), sin(x), cos(x), tan(x), sinh(x), cosh(x), tanh(x), asin(x), acos(x), atan(x), exp(x), log(x), log10(x), floor(x), ceil(x), rint(x)}, означающие соответственно $\sqrt x$, $x^y$, $sin x$, $cos x$, $tg x$, $sh x$, $ch x$, $th x$, $arcsin x$, $arctan x$, $e^x$, $ln x$, $log_{10}x$ и округление в меньшую сторону, большую сторону и к ближайшему целому. Все эти функции работают с типом \cppword{double}. Если добавить к их именам суффикс f, то получатся функции для работы с типом \cppword{float}, а если l, то \cppword{long double}.

Заголовок \cppword{cstdlib} добавляет еще несколько математических функций:

\begin{itemize}

\item \cppword{float fabs(float x)} и \cppword{int abs(int x)}, означающие модуль числа, $|x|$. Также можно использовать функции \cppword{labs} и \cppword{llabs} для типов \cppword{labs} и \cppword{labs} соответственно\footnote{Стандарт C++11 добавил перегрузку для функции \cppword{abs}. Теперь ее можно использовать для работы с любыми целыми типами.}.

\item \cppword{int rand()} --- случайное число от 0 до предустановленного значаения \cppword{RAND\_MAX - 1}.

\item \cppword{void srand(int seed)} --- инициализация генератора случайных чисел. Генераторы, запущенные с одинаковым значением \cppword{seed} создают одинаковые последовательности случайных чисел, как бы странно это ни звучало.

\end{itemize}

В заголовке \cppword{ctime} содержатся средства для работы со временем. Функция \cppword{int time} с аргументом 0 возвращает количество секунд с начала 1970 года.

\showfile{src/cstdlib.cpp}{Случайные числа и время}

Заголовок \cppword{cstring} содержит функции для работы с Си-строками, \cppword{cstdio} --- с файлами, \cppword{cstdlib} --- с памятью в стиле Си, но эти средства мы рассмотрим позже.

\end{document}
