\documentclass[book.tex]{subfiles}

%\input{common}
\begin{document}
\input{fontsize}

\chaptertitle{Скалярные типы}

\maketitle 

\section*{Целые и вещественные типы}

С математической точки зрения целые и вещественные числа принадлежат к бесконечным множествам. У целых нет минимального и максимального значения, а вещественные и того больше --- они могут содержать бесконечное количество значений даже на отрезке от 0 до 1. Для подробной теоретической информации лучше обратиться к теории множеств, мы же лучше рассмотрим ситуацию с практической точки зрения.

\fordummies{

Очевидно, что на реальном устройстве бесконечность реализовать проблематично, а работать с числами надо. Проблема была решена просто --- целые числа ограничили по размеру, а вещественные еще и по точности. Поэтому, если вы услышите упоминания короткого целого или вещестенного числа двойной точности, не пугайтесь. С этими ограничениями связаны пара неочевидных моментов:

\begin{enumerate}
\itemПри арифметических операциях с целыми числами может произойти переполнение --- результат может оказаться больше, чем максимальный размер данного типа.
\itemАрифметические операции с вещественными числами выполняются с определенной точностью и могут содержать погрешность. Поэтому сравнивать вещественные числа на строгое равенство не рекомендуется. Подробно можно посмотреть здесь --- \href{https://0.30000000000000004.com}{https://0.30000000000000004.com}
\end{enumerate}

}

\section*{Целые типы}

В C++ существует несколько стандартных целочисленных типов --- \cppword{bool}, \cppword{char}, \cppword{short}, \cppword{int}, \cppword{long}, \cppword{wchar\_t}, \cppword{char16\_t}\footnote[1]{Появились в стандарте C++11}, \cppword{char32\_t}\footnotemark[1]. Стандарт гарантирует следующее соотношение размеров:

\showfile{src/parts/int_size.cpp}{Размеры целых типов}

\cppword{short}, \cppword{long} и \cppword{long long} --- это сокращения для \cppword{short int}, \cppword{long int} и \cppword{long long int} соответственно. Можно писать и так, и так, смысл от этого не меняется. Также у целого типа есть два модификатора знаковости: знаковый \cppword{signed} (позволяет оперировать числами со знаком) и беззнаковый \cppword{unsigned}, предназначенный для работы с неотрицательными числами. Стандарт гарантирует, что:

\begin{itemize}
\item \cppword{int} имеет размер не меньше 16 бит. Обычно он равен 4 байтам и может содержать значения от -2147483648 до 2147483647 для знакового или от 0 до 4294967295 для беззнакового типа.
\item \cppword{short} имеет размер не меньше 16 бит. Обычно он равен 2 байтам и может содержать значения от -32768 до 32767 для знакового или от до 65535 для беззнакового типа.
\item \cppword{long} имеет размер не меньше 32 бит. Он равен либо 4 байтам как \cppword{int}, либо 8 байтам, и тогда его пределы от $-2^{63}$ до $2^{63} - 1$ или от 0 до $2^{64} - 1$ для беззнакового типа.
\item \cppword{long long} имеет размер не меньше 64 бит. Обычно это 8 байт и тогда его пределы аналогичны типу \cppword{long}.
\end{itemize}

\fordummies{
Чаще всего пользуются знаковыми типами, но иногда применять беззнаковые логичнее. Например, возраст, длина и время как правило больше нуля, поэтому для них разумно использовать \cppword{unsigned}.
}

Вот что можно делать с целыми переменными:

\showfile{src/int_operations.cpp}{Операции с целыми типами}

\section*{Вещественные типы}

Cуществует 3 станадртных вещественных типа --- \cppword{float}, \cppword{double}, \cppword{long double}. По аналогии с целыми они отличаются размерами. Верно, что \cppword{float} $\leq$ \cppword{double} $\leq$ \cppword{long double}. Обычно они имеют следующие ограничения:

\begin{itemize}
\item \cppword{float} имеет размер 32 бит и точность порядка 7 знаков после запятой.
\item \cppword{double} имеет размер 64 бит и точность порядка 15 знаков после запятой.
\item \cppword{long double} может иметь размер 64, 80 или 128 бит и точность выше, чем у \cppword{double}.
\end{itemize}

К вещественным типам применимы те же операции, что и к цеылмм кроме поразрядных, нахождения остатка \cppword{\%}, \cppword{\%=}, инкремента \cppword{++} и декремента \cppword{--}. Операции деления \cppword{/} и \cppword{/=} делят без отбрасывания остатка.

Литералы вещестенного типа задаются 2 способами:

\begin{itemize}
\item Обыкновенным --- \cppword{0.1}, \cppword{1.5}. Если целая или дробнаячасть равна нулю, ее можно не указывать --- \cppword{.3} (0.3), \cppword{1.} (1.0).
\item С указанием порядка --- \cppword{5e-1} ($5*10^{-1}$), \cppword{5E-1} ($5*10^{-1}$), \cppword{50e-2} ($50*10^{-2}$), \cppword{0.5e0} ($0.5*10^{0}$) и \cppword{.5e0} ($0.5*10^{0}$). Порядок указывается как маленькой \cppword{e}, так и большой \cppword{E}. Ноль так же можно опускать.
\end{itemize}

Для точного указания принадлежности литерала к типу \cppword{long double} используют суффиксы \cppword{l} и \cppword{L}, а для \cppword{float} --- \cppword{f} и \cppword{F}:

\showfile{src/parts/float_literals.cpp}{Вещественные литералы}

\section*{Перечисления}

Часто приходится работать с ограниченным набором значений. Например, дней недели всего 7, месяцев 12, а основных цвета, используемых в отрисовке, и вовсе три (RGB --- красный, зеленый и синий). Конечно, можно в таком случае взять обычные целые числа и принять, что 0 --- это понедельник, 1 --- вторник и т.д., но это не очень наглядно. В таком случае удобно использовать перечисления.

Перечисления похожи на целый тип и представляют собой множество констант типа \cppword{int}. Значение каждой следующей константы равно значению предыдущей плюс 1. Нумерация начинается с нуля. Кроме того, константам можно явно присвоить значение.

\showfile{src/enum.cpp}{Использование перечислений}

На этом знакомство со скалярными типами заканчивается. Пришло время перейти к вещам, привычным для программистов, работающих с любыми языками программирования, --- блокам, условиям и ветвлениям.

\end{document}
