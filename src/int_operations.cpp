#include <iostream>

int main() {
    int a = 10, b = 5;//Создаем две переменные целого типа (int) a и b
    //Значение переменной a равно 10, b = 5.
    //Вообще целые числа можно задавать в виде десятичных, восьмеричных и шестнадцатеричных констант.
    //Восьмеричные начинаются с 0, шестнадцатеричные - с 0x или 0X. Регистр не важен.
    //Все эти числа одинаковы:
    int example1 = 0xffff, example2 = 0XFFFF, example3 = 0xFfFf, example4 = 0177777, example5 = 65535;
    //Поскольку символы - это тоже числа, их можно записывать так:
    unsigned char c = 1;//Беззнаковый символ. 1 - код символа. Английские буквы и некоторые специальные символы всегда имеют одинаковые коды. А вот с кириллицей не так, поэтому иногда получаются крякозябры.
    char t = '0'; //А можно так. В одиночных кавычках пишется сам символ.
    char newline = '\n';//С помощью \ записываются специальные символы: \n - переход на новую строку.
    char backslash = '\\'; //Сам бэкслэш \ 
    char apostrophe = '\''; //Апостроф или одиночная кавычка '
    char quote = '\"'; //Двойная кавычка "
    char zero = '\0'; //Нулевой символ - символ с кодом 0.
    char tab = '\t'; //Смивол табуляции
    //А еще можно писать так:
    char code1 = '\100'; // Символ с восьмеричным кодом 100.
    char code2 = '\xff'; // Символ с шестнадцатеричным кодом FF.

    bool flag1 = true, flag2 = false; //Две переменные логического типа bool. 
    //Служебные слова true (истина) и false (ложь) имеют значения 1 и 0 соответственно. Однако, любые ненулевые значения так же считаются истинными.

    /*
    Далее перечислим возможные операции с переменными целого типа
    */
    a = -a; //Унарный минус - меняет знак числа на противоположный. Теперь a = -10
    a = +a; //Унарный плюс. Операция, которая аналогична минусу, но ничего не делает.
    a = +1; //Зато позволяет явно указывать знак у положительных чисел.
    a = a + b;//Сложение. Результат - сумма a и b (a = 1, b = 5, сумма = 6)
    a = 10 - 1;//Вычитание. Результат - 9
    a = 2 * 2;//Произведение. Результат - 4
    a = 10 / 3;//Деление с отбрасыванием остатка. Результат - 3
    b = 10 % 3;//Остаток от деления. Результат - 1

    //Группа побитовых операций:
    a = 1 << 2;//Сдвиг влево числа 1 2 раза. Результат - 4.
    a = 5 >> 1;//Сдвиг вправо числа 5 1 раз. Результат - 2.
    //Т.о. сдвиги представляют собой соответственно умножение и деление на два.
    a = 5 & 3;//Поразрядное логическое И. Бит в результате будет единицей, только если соответствующие биты обоих операндов единицы. Результат - 1. (101 & 11)
    a = 5 | 2;//Поразрядное логическое ИЛИ. Бит в результате будет нулем, только если соответствующие биты обоих операндов нули. Результат - 7. (101 | 10)
    a = 5 ^ 3;//Поразрядное логическое исключающее ИЛИ. Бит в результате будет единицей, если соответствующие биты обоих операндов противоположны. Результат - 6. (101 ^ 11)
    c = ~c; //Поразрадяное логическое отрицание. Инвертируется каждый бит числа. Результат зависит от типа данных. В данном случае он равен 254.

    //Группа логических операций: 
    //Чаще всего они применяются с логическим типом bool, но с другими целыми их тоже можно использовать.
    a = 5 && 7; //Логическое И. Результат равен истине, если оба операнды истинны. В данном случае - 1.
    b = 5 && 0; //Результат - 0.
    a = 5 || 7; //Логическое ИЛИ. Результат истина, если хотя бы один операнд истинен. В данном случае - 1.
    a = ! 5; //Логическое НЕ или отрицание. Результат ложь, если операнд истина и наоборот. В данном случае результат - 0.

    //Операции присваивания:
    a = 1; //Простейший случай: переменной a присваивается значение 1.
    a = b = 2; //Посложнее - сначала b станет равно 2, потом a станет равно b.
    a += 1; //Присваивание с увеличением. Значение a увеличится на 1.
    a = a + 1; //Аналогично предыдущему выражению
    //Аналогично существуют присваивания, совмещенные с другими операциями: -=, *=, %=, /=, <<=, >>=, &=, |= и ^=.

    //И еще две операции, одна из которых дала имя языку:
    c++; //Постфиксный инкремент: увеличивает на 1 значение c, возвращает значение до увеличения. Аналогичен последовательности операций:
    t = c, c += 1, t;
    ++c; //Префиксный инкремент: увеличивает на 1 значение c, возвращает увеличеное значение. Полностью аналогичен операции c += 1;
    --c; //Префиксный декремент: уменьшает на 1 значение c, возвращает уменьшенное значение.
    c--; //Постфиксный декремент: аналогичен постфиксному инкременту.

    //С помощью этих операций можно написать вот такое чудо:
    a = 5;
    a = a++ + ++a; //Но делать так строго не рекомендуется. Результатом здесь будет непоределенное поведение: компилятор может выполнить эти действия в любом порядке.

    //Осталась только одна операция - тернарная: e1 ? e2 : e3;
    //Сначала вычисляется выражение e1. 
    //Если оно истинно, результатом операции будет e2, если ложно - e3.
    a = 2*2 > 3 ? 5 : 2; //Здесь результат 5, т.к. 2*2 > 3
    b = 1+1 == 3 ? 5 : 2; //Здесь результат 2, т.к. 1+1 != 3
    //Применяется она для сокращения записи в условиях.
    return 0;
}