\documentclass[book.tex]{subfiles}

%\input{common}
\begin{document}
\input{fontsize}

\chaptertitle{Типы}

\maketitle 

\section*{Что такое типы}

В повседневной жизни мы регулярно сталкиваемся с классификаций различных объектов. Мы различаем собак и кошек. Кто-то различает марки автомобилей, модели самолетов и вертолетов. Компьютерные игры или фильмы мы часто выбираем по жанру. А когда мы расплачиваемся в магазине, нам важно, что достать из кошелька --- список покупок или денежную купюру. В науке тем или иным образом классифицируется все --- от фундаментальных взаимодействий до животных.

В информационных технологиях классификация данных не менее важна. Работать с изображениями, текстами и числовыми данными нужно по-разному. Для разграничения разных видов данных используют понятие тип данных (тип) --- множество значений и операций на этих значениях. Тип определяет возможные значения и их смысл, операции, а также способы хранения значений типа. Звучит намного сложнее, чем есть на самом деле.

Упрощенно тип данных можно рассматривать как описание, чем является та или иная сущность. Что это --- целое число, строка, символ, массив, какой-то объект и т.п.:

\showfile{src/parts/type1.cpp}{Несколько базовых типов}

Подход к работе с типами бывает разный. Различают статическую и динамическую, а также сильную и слабую типизации.

\fordummies{

Статическая типизация --- подход, при котором некоторая сущность (переменная, параметр подпрограммы, возвращаемое значение функции) связывается с типом в момент объявления и тип не может быть изменён позже. При таком подходе однажды созданная цуелочисленная переменная всегда будет оставаться целым числом и ни при каких обстоятельствах не станет строкой или файлом. Этот подход используется в C, C++, Java и некоторых других языках.

Динамическая типизация --- прием, обратный предыдущему. В нем переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной. Переменная, бывшая когда-то строкой, через некоторое время может стать массивом, а после числом. Такой подход чаще всего используется в скриптовых языках, таких как Python, PHP, Ruby, JavaScript, Perl.

}

\begin{tabularx}{0.95\textwidth}{ | l | >{\hsize=.5\hsize}X | >{\hsize=.5\hsize}X | }
    \hline
    Типизация & Статическая & Динамическая \\\hline
    Преимущества & Самый простой и быстрый машинный код.\newlineМногие ошибки исключаются на стадии компиляции.\newlineЛучшее автодополнение в средах разработки & Легкость в освоении\newlineУдобство описания обобщенных алгоритмов.\newlineПроще работать с внешними данными.\\\hline
    Недостатки & Избыточность написания -- нужно явно указывать типы.\newlineТрудность работы с внешними данными --- JSON, СУБД & Сложнее отладка\newlineНиже производительность --- процессор тратит время на проверку типов\\\hline
\end{tabularx}
\tablecaption{Динамическая и статическая типизация}

\fordummies{

Сильная типизация (иногда говорят строгая) запрещает смешивать сущности разных типов в выражениях. В языках с сильной типизаций автоматические преобразования типов не выполняются. Это такие языки как Java, Python, Haskell.

В слабо типизированных языках смешивание типов в одном выражении разрешено, причем компилятор сам приведет все к единому типу. Также их называют языками с нестрогой типизацией. Это C, JavaScript, Visual Basic, PHP. C++ считается слабо типизированным языком, хотя он более строго относится к преобразованию типов, чем C.

В некоторых слабо типизированных языках автоматически преобразуются только родственные типы, например, числа. А некоторые позвояляют вытворять почти все. В JavaScript, например, допустимы арифметические (!) операции между числом, строкой и массивом. 

}

\begin{tabularx}{0.95\textwidth}{ | l | >{\hsize=.5\hsize}X | >{\hsize=.5\hsize}X | }
    \hline
    Типизация & Сильная & Слабая \\\hline
    Преимущества & Надежность --- вместо неправильного поведения получается ошибка или исключение.\newlineОпределенность --- вы точно знаете, что вы преобразуете и во что, понимая, что такие преобразования могут привести к потере точности и к неверным результатам. & Удобство использования смешанных выражений (например, из целых и вещественных чисел).\newlineАбстрагирование от типизации и сосредоточение на задаче.\newlineКраткость записи. \\\hline
    Недостатки & Избыточность записи --- всегда нужно явно преобразовывать типы & Неоднозначность и отсутствие наглядности. Сложение двух чисел --- однозначная ситуация, а преобразование числа в массив --- нет.\\\hline
\end{tabularx}
\tablecaption{Сильная и слабая типизация}

\section*{Иерархия типов}

В предыдущем пункте упоминались некоторые типы: числа, строки, массивы и т.п. А вот какие типы существуют в C++:

\begin{itemize}
\itemСкалярные: Целые, вещественные, перечисления
\itemСоставные: Массивы, структуры, объединения, классы, функции
\itemУказатели
\end{itemize}

Скалярные типы являются ядром языка. Их еще называют базовыми. По аналогии с математикой переменные скалярного типа могут одновременно иметь только одно значение из множества допустимых.

Составные, что следует из названия, являются комбинацией нескольких типов.  Например, массив целых чисел, структура, содержащая целое число и строку, класс, представляющий собой графический объект - кнопку или текстовое поле и т.п.

Указатели представляют собой адрес ячейки памяти. Фактически это тоже скалярный тип, поскольку адрес можно представить в числовой форме. Однако, набор действий с указателями и их использование несколько отличается от использования базовых типов, поэтому их рассматривают отдельно.

Существует еще и специальный тип \cppword{void}, означающий ничего или пустоту. Переменных этого типа не существует. Он применяется для описания указателей неопределенного типа и функций, не возвращающих значений.

Ко всем типам кроме \cppword{void} применимы следующие операции:

\begin{itemize}
\itemПолучение адреса \cppword{\&}: если \cppword{v} --- переменная типа \cppword{T}, то \cppword{\&v} --- это ее адрес типа \cppword{T*}, т.е. указатель на \cppword{T}.
\itemПолучение размера \cppword{sizeof}: если \cppword{u} --- имя переменной или типа, то \cppword{sizeof(u)} --- размер памяти в байтах, требуемой для хранения \cppword{u}.
\itemСледование \cppword{,}: если \cppword{e1} и \cppword{e2} --- выражения, то \cppword{e1, e2} означает вычислить сначала первое выражение, затем второе, а результатом будет \cppword{e2}.  
\end{itemize}

К скалярным типам и указателям могут применяться операции сравнения: равенства (\cppword{==}), неравенства (\cppword{!=}), больше (\cppword{>}), меньше (\cppword{<}), больше или равно (\cppword{>=}), меньше или равно (\cppword{<=}). Эти операции возвращают логическое значение истина (\cppword{true}) или ложь \cppword{false}. Например:

\showfile{src/parts/compare.cpp}{Сравнения}

Еще одна распространенная операция --- присваивание (\cppword{=}). Присваивать можно все типы кроме массивов и функций. Разумеется, при этом нужно контролировать совместимость --- нельзя, например, присвоить переменной целого типа строку или объект.

\fordummies{
Очень важно понимать, что знак равенства --- это именно присваивание. а не математическое равенство. Выражение \cppword{x = 5} означает \textbf{присвоить} переменной x значение 5. После этой операции в переменной по имени x будет храниться значение 5. Это неравносильно математическому поиску переменной. В математике строка x = 5 означает, что мы нашли значение переменной и оно равно 5. В C++ \cppword{x = 5} означает: мы явно записываем в переменную x значение 5. Таким образом \cppword{x = x + 1} --- это увеличение значения x на 1, а не какой-то математический абсурд.
}

Также нужно не путать присваивание и сравнение. Результатом первого будет значение слева от знака равенства после присваивания, результатом второго --- логическое значение. Однако, если написать \cppword{if (a = b)}, компилятор может и не подсказать, что сравнение должно выглядеть как \cppword{if (a == b)}. Оба варианта синтаксически правильны и различаются только по смысловой нагрузке, поэтому задача по правильному использованию операций ложится на плечи разработчика.

\section*{Целые и вещественные типы}

С математической точки зрения целые и вещественные числа принадлежат к бесконечным множествам. У целых нет минимального и максимального значения, а вещественные и того больше --- они могут содержать бесконечное количество значений даже на отрезке от 0 до 1. Для подробной теоретической информации лучше обратиться к теории множеств, мы же лучше рассмотрим ситуацию с практической точки зрения.

\fordummies{

Очевидно, что на реальном устройстве бесконечность реализовать проблематично, а работать с числами надо. Проблема была решена просто --- целые числа ограничили по размеру, а вещественные еще и по точности. Поэтому, если вы услышите упоминания короткого целого или вещестенного числа двойной точности, не пугайтесь. С этими ограничениями связаны пара неочевидных моментов:

\begin{enumerate}
\itemПри арифметических операциях с целыми числами может произойти переполнение --- результат может оказаться больше, чем максимальный размер данного типа.
\itemАрифметические операции с вещественными числами выполняются с определенной точностью и могут содержать погрешность. Поэтому сравнивать вещественные числа на строгое равенство не рекомендуется. Подробно можно посмотреть здесь --- \href{https://0.30000000000000004.com}{https://0.30000000000000004.com}
\end{enumerate}

}

\section*{Целые типы}

В C++ существует несколько стандартных целочисленных типов --- \cppword{bool}, \cppword{char}, \cppword{short}, \cppword{int}, \cppword{long}, \cppword{wchar\_t}, \cppword{char16\_t}\footnote[1]{Появились в стандарте C++11}, \cppword{char32\_t}\footnotemark[1]. Стандарт гарантирует следующее соотношение размеров:

\showfile{src/parts/int_size.cpp}{Размеры целых типов}

\cppword{short}, \cppword{long} и \cppword{long long} --- это сокращения для \cppword{short int}, \cppword{long int} и \cppword{long long int} соответственно. Можно писать и так, и так, смысл от этого не меняется. Также у целого типа есть два модификатора знаковости: знаковый \cppword{signed} (позволяет оперировать числами со знаком) и беззнаковый \cppword{unsigned}, предназначенный для работы с неотрицательными числами. Стандарт гарантирует, что:

\begin{itemize}
\item \cppword{int} имеет размер не меньше 16 бит. Обычно он равен 4 байтам и может содержать значения от -2147483648 до 2147483647 для знакового или от 0 до 4294967295 для беззнакового типа.
\item \cppword{short} имеет размер не меньше 16 бит. Обычно он равен 2 байтам и может содержать значения от -32768 до 32767 для знакового или от до 65535 для беззнакового типа.
\item \cppword{long} имеет размер не меньше 32 бит. Он равен либо 4 байтам как \cppword{int}, либо 8 байтам, и тогда его пределы от $-2^{63}$ до $2^{63} - 1$ или от 0 до $2^{64} - 1$ для беззнакового типа.
\item \cppword{long long} имеет размер не меньше 64 бит. Обычно это 8 байт и тогда его пределы аналогичны типу \cppword{long}.
\end{itemize}

\fordummies{
Чаще всего пользуются знаковыми типами, но иногда применять беззнаковые логичнее. Например, возраст, длина и время как правило больше нуля, поэтому для них разумно использовать \cppword{unsigned}.
}

Вот что можно делать с целыми переменными:

\showfile{src/int_operations.cpp}{Операции с целыми типами}

\section*{Вещественные типы}

Cуществует 3 станадртных вещественных типа --- \cppword{float}, \cppword{double}, \cppword{long double}. По аналогии с целыми они отличаются размерами. Верно, что \cppword{float} $\leq$ \cppword{double} $\leq$ \cppword{long double}. Обычно они имеют следующие ограничения:

\begin{itemize}
\item \cppword{float} имеет размер 32 бит и точность порядка 7 знаков после запятой.
\item \cppword{double} имеет размер 64 бит и точность порядка 15 знаков после запятой.
\item \cppword{long double} может иметь размер 64, 80 или 128 бит и точность выше, чем у \cppword{double}.
\end{itemize}

К вещественным типам применимы те же операции, что и к цеылмм кроме поразрядных, нахождения остатка \cppword{\%}, \cppword{\%=}, инкремента \cppword{++} и декремента \cppword{--}. Операции деления \cppword{/} и \cppword{/=} делят без отбрасывания остатка.

Литералы вещестенного типа задаются 2 способами:

\begin{itemize}
\item Обыкновенным --- \cppword{0.1}, \cppword{1.5}. Если целая или дробнаячасть равна нулю, ее можно не указывать --- \cppword{.3} (0.3), \cppword{1.} (1.0).
\item С указанием порядка --- \cppword{5e-1} ($5*10^{-1}$), \cppword{5E-1} ($5*10^{-1}$), \cppword{50e-2} ($50*10^{-2}$), \cppword{0.5e0} ($0.5*10^{0}$) и \cppword{.5e0} ($0.5*10^{0}$). Порядок указывается как маленькой \cppword{e}, так и большой \cppword{E}. Ноль так же можно опускать.
\end{itemize}

Для точного указания принадлежности литерала к типу \cppword{long double} используют суффиксы \cppword{l} и \cppword{L}, а для \cppword{float} --- \cppword{f} и \cppword{F}:

\showfile{src/parts/float_literals.cpp}{Вещественные литералы}

\section*{Перечисления}

%TODO:

Описательный пример. Отличие от целого типа и сходство с ним.

\end{document}
