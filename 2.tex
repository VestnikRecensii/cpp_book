\documentclass[book.tex]{subfiles}

%\input{common}
\begin{document}
%\input{fontsize}

\chaptertitle{Типы}

\maketitle 

\section*{Что такое типы}

В повседневной жизни мы регулярно сталкиваемся с классификаций различных объектов. Мы различаем собак и кошек. Кто-то различает марки автомобилей, модели самолетов и вертолетов. Компьютерные игры или фильмы мы часто выбираем по жанру. А когда мы расплачиваемся в магазине, нам важно, что достать из кошелька --- список покупок или денежную купюру. В науке тем или иным образом классифицируется все --- от фундаментальных взаимодействий до животных.

В информационных технологиях классификация данных не менее важна. Работать с изображениями, текстами и числовыми данными нужно по-разному. Для разграничения разных видов данных используют понятие тип данных (тип) --- множество значений и операций на этих значениях. Тип определяет возможные значения и их смысл, операции, а также способы хранения значений типа. Звучит намного сложнее, чем есть на самом деле.

Упрощенно тип данных можно рассматривать как описание, чем является та или иная сущность. Что это --- целое число, строка, символ, массив, какой-то объект и т.п.:

\showfile{src/parts/type1.cpp}{Несколько базовых типов}

Подход к работе с типами бывает разный. Различают статическую и динамическую, а также сильную и слабую типизации.

\fordummies{

Статическая типизация --- подход, при котором некоторая сущность (переменная, параметр подпрограммы, возвращаемое значение функции) связывается с типом в момент объявления и тип не может быть изменён позже. При таком подходе однажды созданная цуелочисленная переменная всегда будет оставаться целым числом и ни при каких обстоятельствах не станет строкой или файлом. Этот подход используется в C, C++, Java и некоторых других языках.

Динамическая типизация --- прием, обратный предыдущему. В нем переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной. Переменная, бывшая когда-то строкой, через некоторое время может стать массивом, а после числом. Такой подход чаще всего используется в скриптовых языках, таких как Python, PHP, Ruby, JavaScript, Perl.

}

\begin{tabularx}{0.95\textwidth}{ | l | >{\hsize=.5\hsize}X | >{\hsize=.5\hsize}X | }
    \hline
    Типизация & Статическая & Динамическая \\\hline
    Преимущества & Самый простой и быстрый машинный код.\newlineМногие ошибки исключаются на стадии компиляции.\newlineЛучшее автодополнение в средах разработки & Легкость в освоении\newlineУдобство описания обобщенных алгоритмов.\newlineПроще работать с внешними данными.\\\hline
    Недостатки & Избыточность написания -- нужно явно указывать типы.\newlineТрудность работы с внешними данными --- JSON, СУБД & Сложнее отладка\newlineНиже производительность --- процессор тратит время на проверку типов\\\hline
\end{tabularx}
\tablecaption{Динамическая и статическая типизация}

\fordummies{

Сильная типизация (иногда говорят строгая) запрещает смешивать сущности разных типов в выражениях. В языках с сильной типизаций автоматические преобразования типов не выполняются. Это такие языки как Java, Python, Haskell.

В слабо типизированных языках смешивание типов в одном выражении разрешено, причем компилятор сам приведет все к единому типу. Также их называют языками с нестрогой типизацией. Это C, JavaScript, Visual Basic, PHP. C++ считается слабо типизированным языком, хотя он более строго относится к преобразованию типов, чем C.

В некоторых слабо типизированных языках автоматически преобразуются только родственные типы, например, числа. А некоторые позвояляют вытворять почти все. В JavaScript, например, допустимы арифметические (!) операции между числом, строкой и массивом. 

}

\begin{tabularx}{0.95\textwidth}{ | l | >{\hsize=.5\hsize}X | >{\hsize=.5\hsize}X | }
    \hline
    Типизация & Сильная & Слабая \\\hline
    Преимущества & Надежность --- вместо неправильного поведения получается ошибка или исключение.\newlineОпределенность --- вы точно знаете, что вы преобразуете и во что, понимая, что такие преобразования могут привести к потере точности и к неверным результатам. & Удобство использования смешанных выражений (например, из целых и вещественных чисел).\newlineАбстрагирование от типизации и сосредоточение на задаче.\newlineКраткость записи. \\\hline
    Недостатки & Избыточность записи --- всегда нужно явно преобразовывать типы & Неоднозначность и отсутствие наглядности. Сложение двух чисел --- однозначная ситуация, а преобразование числа в массив --- нет.\\\hline
\end{tabularx}
\tablecaption{Сильная и слабая типизация}

\section*{Иерархия типов}

В предыдущем пункте упоминались некоторые типы: числа, строки, массивы и т.п. А вот какие типы существуют в C++:

\begin{itemize}
\itemСкалярные: Целые, вещественные, перечисления
\itemСоставные: Массивы, структуры, объединения, классы, функции
\itemУказатели
\end{itemize}

Скалярные типы являются ядром языка. Их еще называют базовыми. По аналогии с математикой переменные скалярного типа могут одновременно иметь только одно значение из множества допустимых.

Составные, что следует из названия, являются комбинацией нескольких типов.  Например, массив целых чисел, структура, содержащая целое число и строку, класс, представляющий собой графический объект - кнопку или текстовое поле и т.п.

Указатели представляют собой адрес ячейки памяти. Фактически это тоже скалярный тип, поскольку адрес можно представить в числовой форме. Однако, набор действий с указателями и их использование несколько отличается от использования базовых типов, поэтому их рассматривают отдельно.

Существует еще и специальный тип \cppword{void}, означающий ничего или пустоту. Переменных этого типа не существует. Он применяется для описания указателей неопределенного типа и функций, не возвращающих значений.

Ко всем типам кроме \cppword{void} применимы следующие операции:

\begin{itemize}
\itemПолучение адреса \cppword{\&}: если \cppword{v} --- переменная типа \cppword{T}, то \cppword{\&v} --- это ее адрес типа \cppword{T*}, т.е. указатель на \cppword{T}.
\itemПолучение размера \cppword{sizeof}: если \cppword{u} --- имя переменной или типа, то \cppword{sizeof(u)} --- размер памяти в байтах, требуемой для хранения \cppword{u}.
\itemСледование \cppword{,}: если \cppword{e1} и \cppword{e2} --- выражения, то \cppword{e1, e2} означает вычислить сначала первое выражение, затем второе, а результатом будет \cppword{e2}.  
\end{itemize}

\section*{Целые и вещественные типы}

С математической точки зрения целые и вещественные числа принадлежат к бесконечным множествам. У целых нет минимального и максимального значения, а вещественные и того больше --- они могут содержать бесконечное количество значений даже на отрезке от 0 до 1. Для подробной теоретической информации лучше обратиться к теории множеств, мы же лучше рассмотрим ситуацию с практической точки зрения.

\fordummies{

Очевидно, что на реальном устройстве бесконечность реализовать проблематично, а работать с числами надо. Проблема была решена просто --- целые числа ограничили по размеру, а вещественные еще и по точности. Поэтому, если вы услышите упоминания короткого целого или вещестенного числа двойной точности, не пугайтесь. С этими ограничениями связаны пара неочевидных моментов:

\begin{enumerate}
\itemПри арифметических операциях с целыми числами может произойти переполнение --- результат может оказаться больше, чем максимальный размер данного типа.
\itemАрифметические операции с вещественными числами выполняются с определенной точностью и могут содержать погрешность. Поэтому сравнивать вещественные числа на строгое равенство не рекомендуется. Подробно можно посмотреть здесь --- \href{https://0.30000000000000004.com}{https://0.30000000000000004.com}
\end{enumerate}

}

В C++ существует несколько стандартных целочисленных типов --- \cppword{bool}, \cppword{char}, \cppword{short}, \cppword{int}, \cppword{long}, \cppword{wchar\_t}, \cppword{char16\_t}\footnote[1]{Появились в стандарте C++11}, \cppword{char32\_t}\footnotemark[1].

Бесконечность. Континуум. Почему так сложилось. Отличия. Операции над типами.

bool, char, int, long, unsigned и т.п.

float, doulbe, long double

\section*{Перечисления}

Описательный пример. Отличие от целого типа и сходство с ним.

\end{document}
