\documentclass[book.tex]{subfiles}

%\input{common}
\begin{document}
\input{fontsize}

\chaptertitle{Типы}

\maketitle 

\section*{Что такое типы}

В повседневной жизни мы регулярно сталкиваемся с классификаций различных объектов. Мы различаем собак и кошек. Кто-то различает марки автомобилей, модели самолетов и вертолетов. Компьютерные игры или фильмы часто выбирают по жанру. А когда мы расплачиваемся в магазине, нам важно, что достать из кошелька --- список покупок или денежную купюру. В науке тем или иным образом классифицируется все --- от фундаментальных взаимодействий до животных.

В информационных технологиях классификация данных не менее важна. Работать с изображениями, текстами и числовыми данными нужно по-разному. Для разграничения разных видов данных используют понятие тип данных (тип) --- множество значений и операций на этих значениях. Тип определяет возможные значения и их смысл, операции, а также способы хранения значений типа. Звучит намного сложнее, чем есть на самом деле.

Упрощенно тип данных можно рассматривать как описание, чем является та или иная сущность. Что это --- целое число, строка, символ, массив, какой-то объект и т.п.:

\showfile{src/parts/type1.cpp}{Несколько базовых типов}

Подход к работе с типами бывает разный. Различают статическую и динамическую, а также сильную и слабую типизации.

\fordummies{

Статическая типизация --- подход, при котором некоторая сущность (переменная, параметр подпрограммы, возвращаемое значение функции) связывается с типом в момент объявления и тип не может быть изменён позже. При таком подходе однажды созданная цуелочисленная переменная всегда будет оставаться целым числом и ни при каких обстоятельствах не станет строкой или файлом. Этот подход используется в C, C++, Java и некоторых других языках.

Динамическая типизация --- прием, обратный предыдущему. В нем переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной. Переменная, бывшая когда-то строкой, через некоторое время может стать массивом, а после числом. Такой подход чаще всего используется в скриптовых языках, таких как Python, PHP, Ruby, JavaScript, Perl.

}

\begin{tabularx}{0.95\textwidth}{ | l | >{\hsize=.5\hsize}X | >{\hsize=.5\hsize}X | }
    \hline
    Типизация & Статическая & Динамическая \\\hline
    Преимущества & Самый простой и быстрый машинный код.\newlineМногие ошибки исключаются на стадии компиляции.\newlineЛучшее автодополнение в средах разработки & Легкость в освоении\newlineУдобство описания обобщенных алгоритмов.\newlineПроще работать с внешними данными.\\\hline
    Недостатки & Избыточность написания -- нужно явно указывать типы.\newlineТрудность работы с внешними данными --- JSON, СУБД & Сложнее отладка\newlineНиже производительность --- процессор тратит время на проверку типов\\\hline
\end{tabularx}
\tablecaption{Динамическая и статическая типизация}

\fordummies{

Сильная типизация (иногда говорят строгая) запрещает смешивать сущности разных типов в выражениях. В языках с сильной типизаций автоматические преобразования типов не выполняются. Это такие языки как Java, Python, Haskell.

В слабо типизированных языках смешивание типов в одном выражении разрешено, причем компилятор сам приведет все к единому типу. Также их называют языками с нестрогой типизацией. Это C, JavaScript, Visual Basic, PHP. C++ считается слабо типизированным языком, хотя он более строго относится к преобразованию типов, чем C.

В некоторых слабо типизированных языках автоматически преобразуются только родственные типы, например, числа. А некоторые позвояляют вытворять почти все. В JavaScript, например, допустимы арифметические (!) операции между числом, строкой и массивом. 

}

\begin{tabularx}{0.95\textwidth}{ | l | >{\hsize=.5\hsize}X | >{\hsize=.5\hsize}X | }
    \hline
    Типизация & Сильная & Слабая \\\hline
    Преимущества & Надежность --- вместо неправильного поведения получается ошибка или исключение.\newlineОпределенность --- вы точно знаете, что вы преобразуете и во что, понимая, что такие преобразования могут привести к потере точности и к неверным результатам. & Удобство использования смешанных выражений (например, из целых и вещественных чисел).\newlineАбстрагирование от типизации и сосредоточение на задаче.\newlineКраткость записи. \\\hline
    Недостатки & Избыточность записи --- всегда нужно явно преобразовывать типы & Неоднозначность и отсутствие наглядности. Сложение двух чисел --- однозначная ситуация, а преобразование числа в массив --- нет.\\\hline
\end{tabularx}
\tablecaption{Сильная и слабая типизация}

\section*{Иерархия типов}

В предыдущем пункте упоминались некоторые типы: числа, строки, массивы и т.п. А вот какие типы существуют в C++:

\begin{itemize}
\itemСкалярные: Целые, вещественные, перечисления
\itemСоставные: Массивы, структуры, объединения, классы, функции
\itemУказатели
\end{itemize}

Скалярные типы являются ядром языка. Их еще называют базовыми. По аналогии с математикой переменные скалярного типа могут одновременно иметь только одно значение из множества допустимых.

Составные, что следует из названия, являются комбинацией нескольких типов. Например, массив целых чисел, структура, содержащая целое число и строку, класс, представляющий собой графический объект - кнопку или текстовое поле и т.п.

Указатели представляют собой адрес ячейки памяти. Фактически это тоже скалярный тип, поскольку адрес можно представить в числовой форме. Однако, набор действий с указателями и их использование несколько отличается от использования базовых типов, поэтому их рассматривают отдельно.

Существует еще и специальный тип \cppword{void}, означающий ничего или пустоту. Переменных этого типа не существует. Он применяется для описания указателей неопределенного типа и функций, не возвращающих значений.

Ко всем типам кроме \cppword{void} применимы следующие операции:

\begin{itemize}
\itemПолучение адреса \cppword{\&}: если \cppword{v} --- переменная типа \cppword{T}, то \cppword{\&v} --- это ее адрес типа \cppword{T*}, т.е. указатель на \cppword{T}.
\itemПолучение размера \cppword{sizeof}: если \cppword{u} --- имя переменной или типа, то \cppword{sizeof(u)} --- размер памяти в байтах, требуемой для хранения \cppword{u}.
\itemСледование \cppword{,}: если \cppword{e1} и \cppword{e2} --- выражения, то \cppword{e1, e2} означает вычислить сначала первое выражение, затем второе, а результатом будет \cppword{e2}.
\end{itemize}

К скалярным типам и указателям могут применяться операции сравнения: равенства (\cppword{==}), неравенства (\cppword{!=}), больше (\cppword{>}), меньше (\cppword{<}), больше или равно (\cppword{>=}), меньше или равно (\cppword{<=}). Эти операции возвращают логическое значение истина (\cppword{true}) или ложь \cppword{false}. Например:

\showfile{src/parts/compare.cpp}{Сравнения}

Еще одна распространенная операция --- присваивание (\cppword{=}). Присваивать можно все типы кроме массивов и функций. Разумеется, при этом нужно контролировать совместимость --- нельзя, например, присвоить переменной целого типа строку или объект.

\fordummies{
Очень важно понимать, что знак равенства --- это именно присваивание. а не математическое равенство. Выражение \cppword{x = 5} означает \textbf{присвоить} переменной x значение 5. После этой операции в переменной по имени x будет храниться значение 5. Это неравносильно математическому поиску переменной. В математике строка x = 5 означает, что мы нашли значение переменной и оно равно 5. В C++ \cppword{x = 5} означает: мы явно записываем в переменную x значение 5. Таким образом \cppword{x = x + 1} --- это увеличение значения x на 1, а не какой-то математический абсурд.
}

Также нужно не путать присваивание и сравнение. Результатом первого будет значение слева от знака равенства после присваивания, результатом второго --- логическое значение. Однако, если написать \cppword{if (a = b)}, компилятор может и не подсказать, что сравнение должно выглядеть как \cppword{if (a == b)}. Оба варианта синтаксически правильны и различаются только по смысловой нагрузке, поэтому задача по правильному использованию операций ложится на плечи разработчика.

\end{document}
